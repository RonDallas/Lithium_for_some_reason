extend class Lith_URANUS;

array<double> m_mapDrawnPoints;
vector2 m_mapCenter, m_mapTopLeft, m_mapBottomRight;
color m_mapColor;
bool m_mapEnabled;

bool, double, vector2, vector2 collideLineAabb(vector2 p, vector2 dt, vector2 center, vector2 s2) {
   let s   = (1.0 / dt.x, 1.0 / dt.y);
   let sgn = (s.x < 0 ? -1 : 1, s.y < 0 ? -1 : 1);
   let near = ((center.x - sgn.x * s2.x - p.x) * s.x,
               (center.y - sgn.y * s2.y - p.y) * s.y);
   let far  = ((center.x + sgn.x * s2.x - p.x) * s.x,
               (center.y + sgn.y * s2.y - p.y) * s.y);
   if(near.x <= far.y && near.y <= far.x) {
      let nt = max(near.x, near.y);
      let ft = min(far.x, far.y);
      if(nt < 1 && ft > 0) {
         let ht = clamp(nt, 0, 1); // depth
         let hd = ((1 - ht) * -dt.x, (1 - ht) * -dt.y); // delta
         let hp = (p.x + dt.x * ht, p.y + dt.y * ht); // pos
         return true, ht, hd, hp;
      }
   }
   return false, 0, (0,0), (0,0);
}

void tickMap() {
   m_mapDrawnPoints.clear();
   m_mapEnabled = false;
   if(!players[consolePlayer].mo ||
      !Lith_UTIL.pData(_pdt_upgrade, UPGR_Minimap))
   {
      return;
   }
   m_mapEnabled = true;
   int hudtype = Lith_UTIL.pData(_pdt_hudtype);
   m_mapColor =
      hudtype != _hud_old ?
      color(Lith_UTIL.pData(_pdt_playercolor, hudtype)) :
      color(255, 255, 0, 0);
   let p = players[consolePlayer].mo;
   m_mapCenter = p.pos.xy;
   m_mapTopLeft     = m_mapCenter - (256, 256);
   m_mapBottomRight = m_mapCenter + (256, 256);
   let sec = p.curSector;
   let s2 = ((m_mapBottomRight.x - m_mapTopLeft.x) / 2,
             (m_mapBottomRight.y - m_mapTopLeft.y) / 2);
   foreach(ln : sec.lines) {
      if((am_cheat != 0 || ln.flags & Line.ML_MAPPED) &&
         !(ln.flags & Line.ML_DONTDRAW) &&
         // wide pass: check line bbox collides with map bbox
         ln.bbox[2] /*TL.x*/ < m_mapBottomRight.x &&
         ln.bbox[3] /*BR.x*/ > m_mapTopLeft.x &&
         ln.bbox[0] /*TL.y*/ > m_mapTopLeft.y &&
         ln.bbox[1] /*BR.y*/ < m_mapBottomRight.y)
      {
         let v1coll =
            ln.v1.p.x < m_mapBottomRight.x && ln.v1.p.x > m_mapTopLeft.x &&
            ln.v1.p.y < m_mapBottomRight.y && ln.v1.p.y > m_mapTopLeft.y;
         let v2coll =
            ln.v2.p.x < m_mapBottomRight.x && ln.v2.p.x > m_mapTopLeft.x &&
            ln.v2.p.y < m_mapBottomRight.y && ln.v2.p.y > m_mapTopLeft.y;
         if(v1coll && v2coll) {
            // slightly narrower pass: if line is entirely within map, draw it
            m_mapDrawnPoints.push(ln.v1.p.x);
            m_mapDrawnPoints.push(ln.v1.p.y);
            m_mapDrawnPoints.push(ln.v2.p.x);
            m_mapDrawnPoints.push(ln.v2.p.y);
         } else {
            // narrow pass: check segment/aabb collision
            bool hit = false; double ht; vector2 hd, hp, end;
            if(v1coll) {
               [hit, ht, hd, hp] = collideLineAabb(ln.v2.p, -ln.delta, m_mapCenter, s2);
               if(!hit) continue;
            } else if(v2coll) {
               [hit, ht, hd, hp] = collideLineAabb(ln.v1.p, ln.delta, m_mapCenter, s2);
               if(!hit) continue;
            } else {
               [hit, ht, hd, hp] = collideLineAabb(ln.v1.p, ln.delta, m_mapCenter, s2);
               let hp1 = hp;
               if(!hit) continue;
               [hit, ht, hd, hp] = collideLineAabb(ln.v2.p, -ln.delta, m_mapCenter, s2);
               if(!hit) continue;
               hd = hp - hp1;
            }
            // draw collided portion
            end = hp - hd;
            m_mapDrawnPoints.push(hp.x);
            m_mapDrawnPoints.push(hp.y);
            m_mapDrawnPoints.push(end.x);
            m_mapDrawnPoints.push(end.y);
         }
      }
   }
}

ui void drawMap(RenderEvent evt) {
   if(!m_mapEnabled) {
      return;
   }
   let sx = m_mapBottomRight.x - m_mapTopLeft.x;
   let sy = m_mapBottomRight.y - m_mapTopLeft.y;
   let osx = 70.0;
   let osy = osx * sx / sy;
   drawRect(0, 0, osx, osy, color(0xFF, m_mapColor.r / 2, m_mapColor.g / 2, m_mapColor.b / 2), (320, 240));
   Font fnt = fntSml();
   for(int i = 0, n = m_mapDrawnPoints.size(); i < n; i += 4) {
      let v1 = ((m_mapDrawnPoints[i]     - m_mapTopLeft.x) / sx * osx,
                (m_mapDrawnPoints[i + 1] - m_mapTopLeft.y) / sy * osy);
      let v2 = ((m_mapDrawnPoints[i + 2] - m_mapTopLeft.x) / sx * osx,
                (m_mapDrawnPoints[i + 3] - m_mapTopLeft.y) / sy * osy);
      drawLn(v1.x, v1.y, v2.x, v2.y, m_mapColor, (320, 240));
   }
}
